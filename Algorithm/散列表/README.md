# 散列表
　　散列的查找算法分为两步。第一步是用散列函数将被查找的键转换为数组的一个索引；第二步是处理碰撞冲突的过程，如拉链法和线性探测法。</br>
　　散列表是算法在时间和空间上作出权衡的典型例子。如果没有内存限制，可以直接将键作为数组的索引，那么所有的查找操作只需要访问内存一次即可完成。但这种理想情况不会经常出现，因为键很多时需要的内存很大。另一方面，如果没有时间限制，可以使用无序数组并顺序查找，这样就只需要很少的内存。散列表使用了适度的空间和时间并在这两个极端之间找到了平衡。
## 散列函数
　　能够将任意键转换为数组范围内的索引。散列函数应该易于计算且能够均匀分布所有的键，即对于任意键，0到M-1之间的每个整数都有相等的可能性与之对应。
#### 除留余数法
　　将整数散列最常用的方法是除留余数法。选择大小为素数M的数组，对于任意正整数k，计算k除以M的余数。这个函数计算容易且能够有效地将键散布在0到M-1之间。如果M不是素数，可能无法利用键中包含的所有信息，导致无法均匀地散列散列值。</br>
　　hash(k) = k mod m
#### 乘法散列法
　　用关键字k乘以常数A(0<A<1)，并取出小数部分，然后用m乘以这个值，再取结果的底。</br>
　　hash(k) = floor(m(kA mod 1))</br>
　　该方法的一个优点是对m的选择没什么特别的要求，一般为2的幂。一般取A=0.618比较理想。
## 解决碰撞
　　当两个关键字散列到同一个值得时候，称之为冲突或碰撞。这里介绍几种解决碰撞的方法。
#### 拉链法
　　![拉链法](http://orvltx8rw.bkt.clouddn.com/github/6.png)</br>
　　为执行find，使用散列函数确定要考察哪个链表，遍历该表并返回关键字的位置。</br>
　　为执行insert，首先确定该元素是否在表中。如果是新元素，插入表的前端或末尾。</br>
　　为执行delete，找到该元素执行链表删除即可。</br>
　　散列表中元素个数与散列表大小的比值称之为装填因子。</br>
#### 开放定址法
　　在开放定址散列算法中，如果有冲突发生，就要尝试选择另外的单元，直到找出空的单元为止。</br>
　　* 线性探测法</br>
　　* 平方探测法</br>
